---
title: "AbxD01 Analysis"
author: "Alyx Schubert"
date: "September 29, 2014"
output: word_document
---

# Introduction

This is a digital notebook to accompany the paper titled, “_” that will be published in _. It was written in R markdown and converted to html using the R knitr package. This enables us to embed the results of our analyses directly into the text to allow for a completely reproducible data analysis pipeline. A github repository is available where you can pull down your own version of the notebook to modify our analysis or adapt it to your analysis.

This document was generated using mothur v.1.33 and R.

# Prcessing 16S gene sequence data in mothur


## First, get the required files.
Sequence files can be found here _. 

The following files can be found through the [mothur wiki](http://www.mothur.org/wiki/MiSeq_SOP): 
silva.bacteria.fasta
trainset9_032012.pds.tax
trainset9_032012.pds.fasta

The following files can be found on the [github repository for this notebook](https://github.com/SchlossLab/abxD01):
abxD01.files

## Now for the curation pipeline.
These sequences were generated using the Illumina MiSeq Platform. For data processing, we followed the MiSeq SOP outlined in the  [Kozich et al. manuscript](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3753973/). These commands come from the outline described in the [MiSeq SOP](http://www.mothur.org/wiki/MiSeq_SOP). 

```
make.contigs(file=abxD01.files, processors=14)
summary.seqs(fasta=abxD01.trim.contigs.fasta, processors=14)
screen.seqs(fasta=abxD01.trim.contigs.fasta, group=abxD01.contigs.groups, summary=abxD01.trim.contigs.summary, maxambig=0, maxlength=275, processors=14)
unique.seqs(fasta=abxD01.trim.contigs.good.fasta)
count.seqs(name=abxD01.trim.contigs.good.names, group=abxD01.contigs.good.groups)
summary.seqs(count=abxD01.trim.contigs.good.count_table)
#Make sure silva.bacteria.fasta file in folder
pcr.seqs(fasta=silva.bacteria.fasta, start=11894, end=25319, keepdots=F, processors=14)
system(mv silva.bacteria.pcr.fasta silva.v4.fasta)
summary.seqs(fasta=silva.v4.fasta)
align.seqs(fasta=abxD01.trim.contigs.good.unique.fasta, reference=silva.v4.fasta, processors=14)
summary.seqs(fasta=abxD01.trim.contigs.good.unique.align, count=abxD01.trim.contigs.good.count_table)
screen.seqs(fasta=abxD01.trim.contigs.good.unique.align, count=abxD01.trim.contigs.good.count_table, summary=abxD01.trim.contigs.good.unique.summary, start=1968, end=11550, maxhomop=8)
summary.seqs(fasta=current, count=current)
filter.seqs(fasta=abxD01.trim.contigs.good.unique.good.align, vertical=T, trump=.)
unique.seqs(fasta=abxD01.trim.contigs.good.unique.good.filter.fasta, count=abxD01.trim.contigs.good.good.count_table)
pre.cluster(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.fasta, count=abxD01.trim.contigs.good.unique.good.filter.count_table, diffs=2)
chimera.uchime(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.fasta, count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.count_table, dereplicate=t, processors=14)
remove.seqs(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.fasta, accnos=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.accnos)
summary.seqs(fasta=current, count=current)
#Make sure the reference and training set files are in the analysis folder
classify.seqs(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.fasta, count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.count_table, reference=trainset9_032012.pds.fasta, taxonomy=trainset9_032012.pds.tax, cutoff=80)
remove.lineage(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.fasta, count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.count_table, taxonomy=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.taxonomy, taxon=Chloroplast-Mitochondria-unknown-Archaea-Eukaryota)
remove.groups(count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.pick.count_table, fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.fasta, taxonomy=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.taxonomy, groups=mock1-mock2-mock3-mock4-mock5-mock6-mock7-mock8)

#renamed fasta, count_table, taxonomy to have shorter names
system(cp abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.pick.taxonomy abxD01.final.taxonomy)
system(cp abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.pick.pick.count_table abxD01.final.count_table)
system(cp abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.fasta abxD01.final.fasta)

set.current(fasta=abxD01.final.fasta, count=abxD01.final.count_table, taxonomy=abxD01.final.taxonomy)

```

## Creating phylotypes

Continuing the pipeline outlined on the mothur wiki's MiSeq SOP.  

```
#PHYLOTYPE analysis:
#Note: label=1 is the genus level, which is the finest you can do, then label=2 is family and so forth
phylotype(taxonomy=abxD01.final.taxonomy)
make.shared(list=abxD01.final.tx.list, count=abxD01.final.count_table)
count.groups()
#The following size 1625 was chosen based on the results of count.groups(). I tried to minimize the number of samples at Day 0 that were dropped at that minimum cutoff.
sub.sample(shared=abxD01.final.tx.shared, size=1625)
classify.otu(list=abxD01.final.tx.list, count=abxD01.final.count_table, taxonomy=abxD01.final.taxonomy)
#tx.2=family, tx.3=order, etc
get.relabund(shared=abxD01.final.tx.2.subsample.shared) 
get.relabund(shared=abxD01.final.tx.3.subsample.shared)
get.relabund(shared=abxD01.final.tx.4.subsample.shared) 
get.relabund(shared=abxD01.final.tx.5.subsample.shared) 
get.oturep(column=abxD01.final.dist, list=abxD01.final.tx.list, label=2-3-4-5, fasta=abxD01.final.fasta, count=abxD01.final.count_table)

```

## Creating OTUs

It is worth noting that while phylotype analysis followed the listed protocol exactly, we deviated from the listed SOP for the OTU analysis.  This was due to the extensive size of this dataset and limitations in our computing abilities. Thus, in a **separate** folder we copied over the following files from earlier in the protocol:
abxD01.trim.contigs.good.unique.good.filter.unique.fasta
abxD01.trim.contigs.good.unique.good.filter.count_table
trainset9_032012.pds.fasta
trainset9_032012.pds.tax

**If this isn't done in a new folder, you will write over all your previous files because they have the same name.**

```
#Changed diffs from 2 to 3
pre.cluster(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.fasta, count=abxD01.trim.contigs.good.unique.good.filter.count_table, diffs=3)
chimera.uchime(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.fasta, count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.count_table, dereplicate=t, processors=14)
remove.seqs(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.fasta, accnos=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.accnos)
summary.seqs(fasta=current, count=current)
#Make sure the reference and training set files are in the analysis folder
classify.seqs(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.fasta, count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.count_table, reference=trainset9_032012.pds.fasta, taxonomy=trainset9_032012.pds.tax, cutoff=80)
remove.lineage(fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.fasta, count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.count_table, taxonomy=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.taxonomy, taxon=Chloroplast-Mitochondria-unknown-Archaea-Eukaryota)
remove.groups(count=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.pick.count_table, fasta=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.fasta, taxonomy=abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.taxonomy, groups=mock1-mock2-mock3-mock4-mock5-mock6-mock7-mock8)

#renamed fasta, count_table, taxonomy to have shorter names
system(cp abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pds.wang.pick.pick.taxonomy abxD01.final.taxonomy)
system(cp abxD01.trim.contigs.good.unique.good.filter.unique.precluster.uchime.pick.pick.pick.count_table abxD01.final.count_table)
system(cp abxD01.trim.contigs.good.unique.good.filter.unique.precluster.pick.pick.pick.fasta abxD01.final.fasta)

set.current(fasta=abxD01.final.fasta, count=abxD01.final.count_table, taxonomy=abxD01.final.taxonomy)

#OTU ANALYSIS:
#changed SOP taxlevel from 4 to 5
cluster.split(fasta=abxD01.final.fasta, count=abxD01.final.count_table, taxonomy=abxD01.final.taxonomy, splitmethod=classify, taxlevel=5, cutoff=0.20)
make.shared(list=abxD01.final.an.unique_list.list, count=abxD01.final.count_table, label=0.03)
count.groups()

#Note: the size varies based on what you see on count.groups, need to check the distribution of day 0 groups and clindamycin group
sub.sample(shared=abxD01.final.an.unique_list.shared, size=1625)
classify.otu(list=abxD01.final.an.unique_list.list, count=abxD01.final.count_table, taxonomy=abxD01.final.taxonomy, label=0.03, cutoff=80)
get.relabund(shared=abxD01.final.an.unique_list.0.03.subsample.shared)
get.oturep(column=abxD01.final.dist, list=abxD01.final.an.unique_list.list, label=0.03, fasta=abxD01.final.fasta, count=abxD01.final.count_table)
collect.single(shared=abxD01.final.an.unique_list.0.03.subsample.shared, calc=chao-invsimpson-sobs-simpsoneven-shannon-jclass, freq=100)
rarefaction.single(freq=100)
#Note summary.single--use the original shared file, and put subsample as same as before, will subsample 1000 times and get avgs
summary.single(calc=nseqs-coverage-chao-sobs-invsimpson-simpsoneven-shannoneven-shannon, shared=abxD01.final.an.unique_list.shared, subsample=1625)
```

# Data Analysis and Paper Figures

## Figure 1: Bargraph

This figure shows the differences in the communities' structures following different antibiotic treatments. The average *C. difficile* CFU/g Feces is also calculated in this code for each treatment group. 

This figure was built using the R script called "abxD01.barcharts.xOTU.test.r" in the abxD01 folder.The input files are listed in Github. The graph can be sorted 2 ways either by the untreated's decreasing relabund, or by the most abundant within each phylum. For each treatment, the resulting *C. difficile* CFU/g Feces is also labeled on the Y axis below the treatment name. 
The parameters I changed in the r script were:
sortbyphyl<-TRUE
graphbyphyl<-FALSE
abx<-c("Untreated", "Ciprofloxacin", "Clindamycin", "Vancomycin", "Streptomycin", "Cefoperazone", "Ampicillin", "Metronidazole")

File saved as "topdose2_tx1_sorted_10x20.pdf" and "topdose2_tx2_sorted_10x20.pdf"."



### Figure 1: Statistics

To compare CFU levels: 
```{r, eval=TRUE}

file<-read.csv("~/Documents/Github/abxD01/Figure 1/abxD01.final.tx.1.subsample.relabund.topdose2.forlogscale.csv", header=T)

data <- file[ which(file$expgroup != '1untr'), ] #choose experimental groups
data$nextDayCFU<-log10(data$nextDayCFU+1) #log transform CFUs
anova(lm(data$nextDayCFU ~ data$expgroup)) #perform anova across experimental groups for CFU

#Which groups are different? Ciprofloxacin was clearly lower
data <- data[ which(data$expgroup != '2cipro'), ] #remove ciprofloxacin to see now if there's a difference in remaining groups
anova(lm(data$nextDayCFU ~ data$expgroup)) 
              
```
Alternatively:
```{r, eval=TRUE}
data<-read.csv("~/Documents/Github/abxD01/Figure 1/abxD01.final.tx.1.subsample.relabund.topdose2.forlogscale.csv", header=T)

data <- file[ which(file$expgroup != '1untr'), ] #choose experimental groups
data$nextDayCFU<-log10(data$nextDayCFU+1) #log transform CFUs
CFU.anova <- aov(nextDayCFU ~ expgroup, data = data)
CFU.tukey <- TukeyHSD(CFU.anova)

library(multcomp)
library(multcompView)
multcompLetters4(CFU.anova, CFU.tukey)
```
The CFU levels were significantly different between the ciprofloxacin treated communities and all other treatments. 


Amova calculation in mothur to determine the uniqueness of each community structure:
```
dist.shared(shared=abxD01.final.an.unique_list.0.03.topdose2.shared, calc=thetayc-jclass, subsample=1625)
amova(phylip=abxD01.final.an.unique_list.0.03.topdose2.thetayc.0.03.lt.ave.dist, design=topdose_design_byABX.txt, iters=1000000)

```
This results in the file called "abxD01.final.an.unique_list.0.03.topdose2.thetayc.0.03.lt.ave.amova" located in the github folder. The results of these are summarized in "amova8expgroups.xlsx".

## Figure 2

This figure shows the correlation analysis of bacterial species present on Day 0 with *C. difficile* levels on Day 1. 

### Figure 2: Correlation Calculations

Before we get to how this graph was made, we first used an R script to calculate the spearman correlation of OTUs' relative abundance. 

The required file is located on Github.

```{r, eval=FALSE}

meta <- read.table('~/Documents/Github/abxD01/Figure 2/abxD01.final.an.unique_list.0.03.subsample.filter16mintotal.shared.correl.topdose2.txt',header=T)
#meta<-meta[1:96] #change based on number of OTUs above .05%, then add 2 for first two cols
c<-1
otu <- c()
cor.spear <- c()
pval.spear <- c()
cor.ken = c()
pval.ken = c()
for(i in 3:length(meta)){
  otu[c] <- colnames(meta[i])
  cor.spear[c] <- cor.test(meta[,2],meta[,i], method="spearman")$estimate
  pval.spear[c] <- cor.test(meta[,2],meta[,i], method="spearman")$p.value
  cor.ken[c] <- cor.test(meta[,2],meta[,i], method="kendall")$estimate #good to see because kendall handles ties
  pval.ken[c] <- cor.test(meta[,2],meta[,i], method="kendall")$p.value #but only works if this is tao-b and not tao-a which im not sure about
  c <- c+1
}

pval.spear<-p.adjust(pval.spear, method='BH') #adjust for multiple comparisons
pval.ken<-p.adjust(pval.ken, method='BH') #adjust for multiple comparisons

results = NULL
results <- matrix(c(otu, cor.spear, pval.spear, cor.ken, pval.ken), ncol=5)
colnames(results) <- c('otu','corSpear','pvalSpear', "corKen", "pvalKen")
results <- results[order(results[,3]),]  #order by pvalue column=3
write.table(results[1:dim(results)[1],], file="~/Documents/Github/abxD01/Figure 2/abxD01.final.an.unique_list.0.03.subsample.filter16mintotal.shared.correl.topdose2.results.txt", sep="\t", row.names=FALSE)

```


### Figure 2: Stipchart

This figure shows correlation values for OTUs with next day *C. difficile* CFU levels calculated across the original set of antibiotic experiments. 

Necessary files are on github, and it was made using the following code: 

```{r, eval=FALSE}

##Paper Figure: correlations for topdose 
otuCorrs<-read.csv("~/Documents/Github/abxD01/Figure 2/corr_avgAbove0.001_topdose2_stripchart.csv", header=T)
#labels=c("Lachnospiraceae", "Ruminococcaceae", "Clostridia", "Lactobacillales", "Firmicutes", "Bacillales", "Porphyromonadaceae", "Bacteroidales", "Bacteroidetes", "Actinobacteria", "Proteobacteria", "Anaeroplasma", "Deinococcus", "Unclassified")
#ns=c("n=18", "n=9", "n=8", "n=4", "n=2", "n=1", "n=15", "n=4", "n=1", "n=4", "n=3", "n=1", "n=1", "n=3")

#test<-otuCorrs[otuCorrs$phyl=="Bacteroidetes",]
#length(unique(test$family))

pch <- c(1,1,1,1, 6,6, 6, 6, 6, 6, 6, 6,0, 0, 9, 2, 2, 4)
par(mar=c(12, 7, 2, 2) +0.1, mgp=c(4, 1, 0)) #default is 5.1 4.1 4.1 2.1 [bottom, left, top, right space], mgp=c(3, 1, 0) [label line location for x/y location labels, tick mark labels location, tick mark locations]
stripchart(otuCorrs$corr ~ otuCorrs$graphOrder, vertical=TRUE, ylab="Spearman Correlation", ylim=c(-1, 1), cex.axis=1.1, cex=2, pch=pch, lwd=2, col="black",  method="jitter",  jitter=0.25, cex.lab=1.3, yaxt="n", xaxt="n")
axis(1, cex.axis=1, at=(1:nlevels(otuCorrs$family)), labels=FALSE)
text(1:nlevels(otuCorrs$family)+.1, par("usr")[3]-0.05, label=unique(otuCorrs$family), xpd=NA, pos=2, srt=45, cex=1.2)
#text(1:nlevels(otuCorrs$family), par("usr")[3]-0.01, label=ns, xpd=NA, pos=1, cex=.9)
axis(2, cex.axis=1.1, at=seq(-1,+1, by=.1), las=1)
abline(v=c(1:nlevels(otuCorrs$family)), col="dark gray")
#abline(h=c(.3, -.3), col="dark gray", lty="dashed", lwd=4) #change to something else
abline(h=0, col="black", lwd=2)
abline(h=c(0.25, 0.5, 0.75, -0.25, -0.5, -0.75), col="light gray", lwd=2, lty="dashed")
legend("top", legend=unique(otuCorrs$phyl), pch=c(1, 6, 0, 9, 2, 4), cex=0.7, bty="o", horiz=TRUE)

```

Figure saved as "corr_avgAbove0.001_topdose2_10x8.pdf".

## Figure 3

### Figure 3: Barchart

This figure shows the effect of titrating antibiotics on the community as well as the resulting *C. difficile* levels.  

The code for this is the script "abxD01.barcharts.xOTU.test.r" in the paper's home Github directory. Opening this file, the parameters I changed in the top were:
sortbyphyl<-TRUE
graphbyphyl<-TRUE
abx<-c("5 mg/ml", "0.5 mg/ml", "0.1 mg/ml")
file
fileIDS

The file/fileIDS should be matched by the titration.
Input files on github:
1. abxD01.final.tx.2.subsample.allceftitr.forlogscale.csv
2. abxD01.final.tx.2.subsample.allstreptitr.forlogscale.csv
3. abxD01.final.tx.2.subsample.allvanctitr.forlogscale.csv
4. allceftitr_tx2_barchart_ids.csv
5. allstreptitr_tx2_barchart_ids.csv
6. allvanctitr_tx2_barchart_ids.csv

For this graph I decided to take out the untreated communities to highlight the differences among titration groups. So in r I changed the file a bit:

```{r, eval=FALSE}
file<-file[file$expgroup!="1untrStrep",]
#alternatively for the other titrated antibiotics it's "1untrCef", or "1untrVanc"
```

### Figure 3: Statistics

```{r, eval=FALSE}
file<-read.csv("~/Documents/Github/abxD01/Figure 3/abxD01.final.tx.2.subsample.allstreptitr.forlogscale.csv", header=T)
file<-file[file$expgroup!="1untrStrep",]
kruskal.test(file$Otu001 ~ file$expgroup)
kruskal.test(file$Otu003 ~ file$expgroup)
kruskal.test(file$Otu002 ~ file$expgroup)
kruskal.test(file$Otu005 ~ file$expgroup)
kruskal.test(file$Otu004 ~ file$expgroup)
kruskal.test(file$Otu014 ~ file$expgroup)
kruskal.test(file$Otu006 ~ file$expgroup)
kruskal.test(file$Otu007 ~ file$expgroup)
kruskal.test(file$Otu009 ~ file$expgroup)
kruskal.test(file$Otu015 ~ file$expgroup)
kruskal.test(file$Otu017 ~ file$expgroup)
kruskal.test(file$Other ~ file$expgroup)

test <- pairwise.wilcox.test(file$Otu001, file$expgroup, p.adj="BH")
comparisons <- length(test$p.value[]) - sum(is.na(test$p.value))


pairwise.wilcox.test(file$Otu003, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu005, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu002, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu004, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu014, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu006, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu007, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu009, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu015, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu017, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Other, file$expgroup, p.adj="BH")

file<-read.csv("~/Documents/Github/abxD01/Figure 3/abxD01.final.tx.2.subsample.allvanctitr.forlogscale.csv", header=T)
file<-file[file$expgroup!="1untrVanc",]
kruskal.test(file$Otu001 ~ file$expgroup)
kruskal.test(file$Otu002 ~ file$expgroup)
kruskal.test(file$Otu003 ~ file$expgroup)
kruskal.test(file$Otu005 ~ file$expgroup)
kruskal.test(file$Otu004 ~ file$expgroup)
kruskal.test(file$Otu014 ~ file$expgroup)
kruskal.test(file$Otu006 ~ file$expgroup)
kruskal.test(file$Otu007 ~ file$expgroup)
kruskal.test(file$Otu008 ~ file$expgroup)
kruskal.test(file$Otu019 ~ file$expgroup)
kruskal.test(file$Otu018 ~ file$expgroup)
kruskal.test(file$Otu017 ~ file$expgroup)
kruskal.test(file$Other ~ file$expgroup)

pairwise.wilcox.test(file$Otu001, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu003, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu005, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu002, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu004, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu014, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu006, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu007, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu008, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu019, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu018, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu017, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Other, file$expgroup, p.adj="BH")


file<-read.csv("~/Documents/Github/abxD01/Figure 3/abxD01.final.tx.2.subsample.allceftitr.forlogscale.csv", header=T)
file<-file[file$expgroup!="1untrCef",]
kruskal.test(file$Otu001 ~ file$expgroup)
kruskal.test(file$Otu002 ~ file$expgroup)
kruskal.test(file$Otu003 ~ file$expgroup)
kruskal.test(file$Otu005 ~ file$expgroup)
kruskal.test(file$Otu004 ~ file$expgroup)
kruskal.test(file$Otu014 ~ file$expgroup)
kruskal.test(file$Otu006 ~ file$expgroup)
kruskal.test(file$Otu007 ~ file$expgroup)
kruskal.test(file$Otu008 ~ file$expgroup)
kruskal.test(file$Otu009 ~ file$expgroup)
kruskal.test(file$Otu019 ~ file$expgroup)
kruskal.test(file$Otu018 ~ file$expgroup)
kruskal.test(file$Otu016 ~ file$expgroup)
kruskal.test(file$Otu024 ~ file$expgroup)
kruskal.test(file$Otu011 ~ file$expgroup)
kruskal.test(file$Other ~ file$expgroup)

pairwise.wilcox.test(file$Otu001, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu003, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu005, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu002, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu004, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu014, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu006, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu007, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu008, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu009, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu011, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu019, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu018, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu016, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Otu024, file$expgroup, p.adj="BH")
pairwise.wilcox.test(file$Other, file$expgroup, p.adj="BH")

```


## Figure 4

This figure is a heatmap showing the correlation analysis results for the original set of antibiotic treatments and doses with the titration data sets.

2 input files found in Figure 4 github folder:
1. correl_heatmap_0.01rel_topdose2_newtitr.csv
2. correl_heatmapSIDE_0.01rel_topdose2_newtitr.csv


```{r, eval=FALSE}
library(gplots)
correl<- read.csv("~/Desktop/mothur/abxD01/correlation/correl_heatmap_0.01rel_topdose2_newtitr.csv", header=T)

row.names(correl)<-correl$OTU
correl_matrix<-data.matrix(correl)
correl_matrix<-correl_matrix[,-1]
correl_matrix<-data.matrix(correl_matrix)
my_palette <- colorRampPalette(c("blue", "white", "red"))(n = 299)
breaks = c(seq(-1,-.33,length=100),seq(-.33,.33,length=100),seq(.33,1,length=100))#changed to equal numbers


side<-scan("~/Desktop/mothur/abxD01/correlation/correl_heatmapSIDE_0.01rel_topdose2_newtitr.csv", what=",", sep=",")
side2<-read.csv("~/Desktop/mothur/abxD01/correlation/correl_heatmapSIDE_0.01rel_topdose2_newtitr.csv", header=T)
side3<-as.matrix(side2)

sig <- read.csv("~/Desktop/mothur/abxD01/correlation/correl_heatmap_0.01rel_topdose2_newtitr_significance.csv",header=T,stringsAsFactors=F)
sig<-sig[,-1]

par(mar=c(5, 4, 4, 2) +0.1) #default is 5.1 4.1 4.1 2.1
correl_heatmap<-heatmap.2(correl_matrix, scale="none",  col=my_palette, breaks=breaks, density.info="none",  RowSideColors=side3[,2], labRow=side3[,1], trace="none",margins=c(8, 25), dendrogram="none",  Rowv=FALSE, Colv=FALSE,  na.color="black", cexCol=.9,  key=TRUE, keysize=1, cexRow=1, cellnote=as.matrix(sig), notecol="dark gray", notecex = 0.5) #then plot was 7x17in, portrait

```

Each row in this heatmap represents a single OTU. The side colors show broad taxonomic groups of each OTU. The subsequent columns show the correlation value for each OTU (Day 0) with Day 1 *C. difficile* colonization levels by plating. The first column represents the correlations calculations over all the original antibiotics used in the study. The last 3 columns represent the correlation calculations over the titration experiments for the given antibiotic. An example pdf of this figure is on github.

## Figure 5

### Figure 5: Random Forest Analysis

Performed RF analysis on family level phylotypes:
```{r, eval=FALSE}
topdose_tx2<-read.csv("~/Documents/Github/abxD01/Figure 5/abxD01.final.tx.2.subsample.2.shared.rf.topdose.regression.logtrans.csv", header=T)
topdose_tx2<-topdose_tx2[,-1]

library(randomForest)

#fit the randomforest model
model_tx2 <- randomForest(nextDayCFU~., 
                      data = topdose_tx2,  outscale=TRUE,
                      importance=TRUE, proximity=TRUE,
                      keep.forest=TRUE, ntree=5000
)
plot(model_tx2)

print(model_tx2)


#what are the important variables (via permutation) #type 1 is mean decrease in accuracy, type 2 is mean decrease in node impurity
par(mfrow=c(1, 1)) 
varImpPlot(model_tx2, type=1)
imp<-importance(model_tx2)
most.imp<-rownames(imp[order(imp[, "%IncMSE"], decreasing=T)[1:17],])
```


### Figure 5: Barchart

This figure shows the difference between the Day 0's in the delayed and original treatments for metronidazole. The figure is shown as a pdf on github.

Input files found on github:
1. abxD01.final.tx.2.subsample.2.metro.relabund.D0s.csv

```{r, eval=FALSE}
#First calculating:
metroD0<-read.csv("~/Documents/Github/abxD01/Figure 5/abxD01.final.tx.2.subsample.2.metro.relabund.D0s.csv", header=T)

avg01<-tapply(metroD0$Otu001, metroD0$order, mean)
sd01<-tapply(metroD0$Otu001, metroD0$order, sd)

# avg14<-tapply(metroD0$Otu014, metroD0$order, mean)
# sd14<-tapply(metroD0$Otu014, metroD0$order, sd)

avg07<-tapply(metroD0$Otu007, metroD0$order, mean)
sd07<-tapply(metroD0$Otu007, metroD0$order, sd)

# avg09<-tapply(metroD0$Otu009, metroD0$order, mean)
# sd09<-tapply(metroD0$Otu009, metroD0$order, sd)

avg02<-tapply(metroD0$Otu002, metroD0$order, mean)
sd02<-tapply(metroD0$Otu002, metroD0$order, sd)

avg13<-tapply(metroD0$Otu013, metroD0$order, mean)
sd13<-tapply(metroD0$Otu013, metroD0$order, sd)

avg03<-tapply(metroD0$Otu003, metroD0$order, mean)
sd03<-tapply(metroD0$Otu003, metroD0$order, sd)

avg05<-tapply(metroD0$Otu005, metroD0$order, mean)
sd05<-tapply(metroD0$Otu005, metroD0$order, sd)

avg08<-tapply(metroD0$Otu008, metroD0$order, mean)
sd08<-tapply(metroD0$Otu008, metroD0$order, sd)

avg06<-tapply(metroD0$Otu006, metroD0$order, mean)
sd06<-tapply(metroD0$Otu006, metroD0$order, sd)

avg04<-tapply(metroD0$Otu004, metroD0$order, mean)
sd04<-tapply(metroD0$Otu004, metroD0$order, sd)

# avg12<-tapply(metroD0$Otu012, metroD0$order, mean)
# sd12<-tapply(metroD0$Otu012, metroD0$order, sd)


# avg11<-tapply(metroD0$Otu011, metroD0$order, mean)
# sd11<-tapply(metroD0$Otu011, metroD0$order, sd)
# 
# avg05<-tapply(metroD0$Otu005, metroD0$order, mean)
# sd05<-tapply(metroD0$Otu005, metroD0$order, sd)
# 
# avg16<-tapply(metroD0$Otu016, metroD0$order, mean)
# sd16<-tapply(metroD0$Otu016, metroD0$order, sd)


#Now graphing:
par(mfrow=c(3, 3)) 

par(mar=c(2, 4, 2, 3) +0.1)
plot01<-barplot(avg01, col="black", cex.axis=1.3, xaxt="n") 
#error.bar(plot01, avg01, sd01) #plot SD
axis(1, at=plot01, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

# par(mar=c(2, 4, 2, 3) +0.1)
# plot14<-barplot(avg14, col="black", cex.axis=1.3, xaxt="n") 
# #error.bar(plot14, avg14, sd14) #plot SD
# axis(1, at=plot14, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 3, 2, 3) +0.1)
plot07<-barplot(avg07, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot07, avg07, sd07) #plot SD
axis(1, at=plot07, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

# par(mar=c(2, 3, 2, 3) +0.1)
# plot09<-barplot(avg09, col="black", cex.axis=1.3, xaxt="n")
# #error.bar(plot09, avg09, sd09) #plot SD
# axis(1, at=plot09, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 4, 2, 3) +0.1)
plot02<-barplot(avg02, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot02, avg02, sd02) #plot SD
axis(1, at=plot02, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 4, 2, 3) +0.1)
plot13<-barplot(avg13, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot13, avg13, sd13) #plot SD
axis(1, at=plot13, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 3, 2, 3) +0.1)
plot03<-barplot(avg03, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot03, avg03, sd03) #plot SD
axis(1, at=plot03, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 3, 2, 3) +0.1)
plot05<-barplot(avg05, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot05, avg05, sd05) #plot SD
axis(1, at=plot05, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 3, 2, 3) +0.1)
plot08<-barplot(avg08, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot08, avg08, sd08) #plot SD
axis(1, at=plot08, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 3, 2, 3) +0.1)
plot06<-barplot(avg06, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot06, avg06, sd06) #plot SD
axis(1, at=plot06, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

par(mar=c(2, 3, 2, 3) +0.1)
plot04<-barplot(avg04, col="black", cex.axis=1.3, xaxt="n")
#error.bar(plot04, avg04, sd04) #plot SD
axis(1, at=plot04, labels=c("D0", "D0 Recovered"), cex.axis=1.7)

# par(mar=c(2, 3, 2, 3) +0.1)
# plot12<-barplot(avg12, col="black", cex.axis=1.3, xaxt="n")
# #error.bar(plot12, avg12, sd12) #plot SD
# axis(1, at=plot12, labels=c("D0", "D0 Recovered"), cex.axis=1.7)
# 

# par(mar=c(2, 4, 2, 3) +0.1)
# plot11<-barplot(avg11, col="black", cex.axis=1.3, xaxt="n")
# error.bar(plot11, avg11, sd11) #plot SD
# axis(1, at=plot11, labels=c("D0", "D0 Recovered"), cex.axis=1.7)
# 
# par(mar=c(2, 4, 2, 3) +0.1)
# plot16<-barplot(avg16, col="balck", cex.axis=1.3, xaxt="n")
# error.bar(plot16, avg16, sd16) #plot SD
# axis(1, at=plot16, labels=c("D0", "D0 Recovered"), cex.axis=1.7)




#Now figure legend:
plot(1, type="n", axes=F, xlab="", ylab="")

leg<-c("Porphyromonadaceae", "Bacteroides","Erysipelotrichaceae" )
col<-c("darkblue",  "steelblue", "darkgreen" )
#pch<-c(16, 16, 16)
legend("left", legend=leg, pch=15, col=col,  cex=1.7, bty="n", ncol=1)

plot(1, type="n", axes=F, xlab="", ylab="")

leg<-c("Lachnospiraceae",  "Lactobacillus", "Ruminococcaceae" )
col<-c("darkred", "orange2", "gold1" )
#pch<-c(16, 16, 16)
legend("left", legend=leg, pch=15, col=col,  cex=1.7, bty="n", ncol=1)

plot(1, type="n", axes=F, xlab="", ylab="")

leg<-c("Bifidobacterium",  "Enterobacteriaceae","Akkermansia" )
col<-c("deeppink3", "blueviolet", "black" )
#pch<-c(16, 16, 16)
legend("left", legend=leg, pch=15, col=col,  cex=1.7, bty="n", ncol=1)


par(mfrow=c(1, 1)) 


```



## Figure 6
 
This figure shows the results of our model predicting *C. difficile* colonization given relative abundances of a subset of bacteria.

### Figure 6: Model Building

In order to determine the best possible set of models, I first narrowed down the list of candidate OTUs to be considered in the model. This candidate list was created using several criteria, based on the data from the original set of antibiotic experiments alone:

1. Using top 15 results from random forest's feature selection. These OTUs had the highest % increase in MSE in the random forest regression model. These 15 were the top OTUs that were also not "unclassified".
2. Incorporating both the top 5 most positively correlated OTUs and 10 most negatively correlated OTUs. We used the spearman correlation analysis for this, see Figure 2. The number of significantly negatively correlated OTUs far outnumber the number of signifacntly positive correlated OTUs. Due to this difference we chose to incorporate more negative OTUs over positive.
3. Using sparCC in mothur to determine any strong correlations (>90%) among the candidate list OTUs. We found the highest correlation between OTUs to be 84.0% between OTUs 6 & 7, which subsequently dropped off to 70.1%. This was not high enough to consider eliminating from the list.

For the model, I limited models to include anywhere from 1 to 10 parameters. I log transformed the *C. difficile* CFU/g feces on Day 1 for inclusion in a linear model. The OTU data was in the form of a shared file.  

The script for running this code is called "abxD01.lmModel.compare2.R". The input files for this script are:
1. abxD01.final.an.unique_list.0.03.subsample.filter16mintotal.shared.topdose2.logtrans.15otus.rfnegpos.csv

I found a program "leaps" in r which will calculate all subsets of a model for a given range of parameters in the model. That is what is used in the above .R file. The methods I used were an exhaustive search and sequential replacement, which is a combination of both forward and backward stepwise directions for model building.  Both of these methods produced similar results. Interestingly, the top models in both methods included 5 common OTUs: 6, 7, 20, 39, and 283 corresponding to a porphyromonadaceae, porphyromonadaceae, alistipes, lachnospiraceae, and blautia OTU respectively.  The blautia OTU is the only one in the group positively (though low and not significantly) correlated with *C. difficile* CFU. There are also several OTUs from the candidate list that did not appear in the top models.

### Figure 6: Model Building - Random Forest's Feature Selection

The input file includes the Day 0 shared values for OTUs (whose relative abundance was equal to or greater than 1%) and the log transformed next day CFU values (log(CFU)).

Then in r: 
```{r, eval=TRUE}
topdose_logtrans<-read.csv("~/Desktop/mothur/abxD01/rf/abxD01.final.an.unique_list.0.03.subsample.0.03.pick.shared.rf.topdose2.regression.logtrans.filter16mintot.csv", header=T)
training_logtrans<-topdose_logtrans[,-1]
newtit_logtrans<-read.csv("~/Desktop/mothur/abxD01/rf/abxD01.final.an.unique_list.0.03.subsample.0.03.pick.shared.rf.newtitration.regression.logtrans.filter16mintot.csv", header=T)
testing_logtrans<-newtit_logtrans[,-1] #new titration data only
delay_logtrans<-read.csv("~/Desktop/mothur/abxD01/rf/abxD01.final.an.unique_list.0.03.subsample.0.03.pick.shared.rf.delays.regression.logtrans.csv", header=T)
testing2_logtrans<-delay_logtrans[,-1]

library(randomForest)

#fit the randomforest model
model_logtrans <- randomForest(nextDayCFU~., 
                      data = training_logtrans,  outscale=TRUE,
                      importance=TRUE, proximity=TRUE,
                      keep.forest=TRUE, ntree=5000
)
plot(model_logtrans)

print(model_logtrans)


#what are the important variables (via permutation) #type 1 is mean decrease in accuracy, type 2 is mean decrease in node impurity
varImpPlot(model_logtrans, type=1)
imp<-importance(model_logtrans)
most.imp<-rownames(imp[order(imp[, "%IncMSE"], decreasing=T)[1:17],])


#predict the outcome of the testing data
predicted_logtrans <- predict(model_logtrans, newdata=testing_logtrans[ ,-1])
predicted2_logtrans <- predict(model_logtrans, newdata=testing2_logtrans[ ,-1])

# what is the proportion variation explained in the outcome of the testing data?
# i.e., what is 1-(SSerror/SStotal)
actual_logtrans <- testing_logtrans$nextDayCFU
actual2_logtrans <- testing2_logtrans$nextDayCFU

ybar = mean(actual_logtrans)
SSres = sum((actual_logtrans-predicted_logtrans)^2)
SStot = sum((actual_logtrans-ybar)^2)
rsq = 1-(SSres/SStot)

#rsq_logtrans <- 1-sum((actual_logtrans-predicted_logtrans)^2)/sum((actual_logtrans-mean(actual_logtrans))^2)
print(rsq)

ybar2 = mean(actual2_logtrans)
SSres2 = sum((actual2_logtrans-predicted2_logtrans)^2)
SStot2 = sum((actual2_logtrans-ybar2)^2)
rsq2 = 1-(SSres2/SStot2)

print(rsq2)

write.table(cbind(actual_logtrans, predicted_logtrans), file="~/Desktop/mothur/abxD01/rf/RF.regression.topTitr.txt", sep="\t", row.names=FALSE)

```

The "plot(model_logtrans)" shows that setting ntree=5000 is enough to get a consistently low error. 

We can also see from printing the results that the percent variation explained is 88.4%. 



